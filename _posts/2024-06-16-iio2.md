---
layout: post
title: "Kernel Devlog #3 - Guess who's back"
date: 2024-06-16 14:25:06
description: "Back again"
tags: 
 - MAC5856
---

## ad7292: Round Two
With all other projects completed, it was now time to go back to ad7292 differential mode implementation. I spoke with the original developer of the driver, a former student at my university, and he helped me plan out my steps. I'd have to:
1. add ```IIO_CHAN_INFO_SCALE``` and ```IIO_CHAN_INFO_OFFSET``` to the channel definitions,
2. alter ```IIO_CHAN_INFO_SCALE``` to properly return 9 instead of 10 in differential channels,
3. implement IIO_CHAN_INFO_OFFSET, and
4. configure the device to operate in differential mode, which requires me to write a bit into a specific subregister, so I'd have to implement a ad7292_spi_subreg_write() function too.

## Binary time
I spoke at length about binary encoding in the previous kernel post, so I won't be going into that this time. The encoding used is 10-bit signed offset binary, which means to convert the 10-bit code I receive to a regular number, I have to subtract ```0x200``` (the midpoint offset) and signal to the IIO enviroment that the scale is relative to ```2^9``` possible values, not ```2^10``` like in the straight binary case (as one of our bits is used for the sign).  The offset is done in the aptly named ```IIO_CHAN_INFO_OFFSET``` case of ```read_raw``` and the scale adjustment is just an ```if``` in the ```IIO_CHAN_INFO_SCALE``` case. That dealt with steps 1, 2 and 3.

## Step 4: uhhhhhh
I hadn't expected to need to add new functionality to the driver when I first took on this project in the beginning of the semester, but it was easier than expected. I had to read a bunch of documentation to make sure what I was doing was correct, but it was a simple function to implement and it should work as expected. According to the device's datasheet, I'd need to send a 8 bit signal composed of a write bit and the address of a register, followed by another 8 bit signal composed of the address of the subregister and finally the 16 bit code that I want to write to that subregister. Since I only want to change a specific bit, I'll read the subregister values, replace the bit I want to change and write the changed version back into the device. I still haven't tested the code, but hopefully it'll work (it does compile, at least). I'll try to add more examples to show it off properly soon.